// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'backend_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$BackendFailureTearOff {
  const _$BackendFailureTearOff();

  NameInvalid nameInvalid() {
    return const NameInvalid();
  }

  DoubledNameInvalid doubledNameInvalid() {
    return const DoubledNameInvalid();
  }

  ServerError serverError() {
    return const ServerError();
  }
}

// ignore: unused_element
const $BackendFailure = _$BackendFailureTearOff();

mixin _$BackendFailure {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result nameInvalid(),
    @required Result doubledNameInvalid(),
    @required Result serverError(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result nameInvalid(),
    Result doubledNameInvalid(),
    Result serverError(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result nameInvalid(NameInvalid value),
    @required Result doubledNameInvalid(DoubledNameInvalid value),
    @required Result serverError(ServerError value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result nameInvalid(NameInvalid value),
    Result doubledNameInvalid(DoubledNameInvalid value),
    Result serverError(ServerError value),
    @required Result orElse(),
  });
}

abstract class $BackendFailureCopyWith<$Res> {
  factory $BackendFailureCopyWith(
          BackendFailure value, $Res Function(BackendFailure) then) =
      _$BackendFailureCopyWithImpl<$Res>;
}

class _$BackendFailureCopyWithImpl<$Res>
    implements $BackendFailureCopyWith<$Res> {
  _$BackendFailureCopyWithImpl(this._value, this._then);

  final BackendFailure _value;
  // ignore: unused_field
  final $Res Function(BackendFailure) _then;
}

abstract class $NameInvalidCopyWith<$Res> {
  factory $NameInvalidCopyWith(
          NameInvalid value, $Res Function(NameInvalid) then) =
      _$NameInvalidCopyWithImpl<$Res>;
}

class _$NameInvalidCopyWithImpl<$Res> extends _$BackendFailureCopyWithImpl<$Res>
    implements $NameInvalidCopyWith<$Res> {
  _$NameInvalidCopyWithImpl(
      NameInvalid _value, $Res Function(NameInvalid) _then)
      : super(_value, (v) => _then(v as NameInvalid));

  @override
  NameInvalid get _value => super._value as NameInvalid;
}

class _$NameInvalid implements NameInvalid {
  const _$NameInvalid();

  @override
  String toString() {
    return 'BackendFailure.nameInvalid()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NameInvalid);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result nameInvalid(),
    @required Result doubledNameInvalid(),
    @required Result serverError(),
  }) {
    assert(nameInvalid != null);
    assert(doubledNameInvalid != null);
    assert(serverError != null);
    return nameInvalid();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result nameInvalid(),
    Result doubledNameInvalid(),
    Result serverError(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (nameInvalid != null) {
      return nameInvalid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result nameInvalid(NameInvalid value),
    @required Result doubledNameInvalid(DoubledNameInvalid value),
    @required Result serverError(ServerError value),
  }) {
    assert(nameInvalid != null);
    assert(doubledNameInvalid != null);
    assert(serverError != null);
    return nameInvalid(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result nameInvalid(NameInvalid value),
    Result doubledNameInvalid(DoubledNameInvalid value),
    Result serverError(ServerError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (nameInvalid != null) {
      return nameInvalid(this);
    }
    return orElse();
  }
}

abstract class NameInvalid implements BackendFailure {
  const factory NameInvalid() = _$NameInvalid;
}

abstract class $DoubledNameInvalidCopyWith<$Res> {
  factory $DoubledNameInvalidCopyWith(
          DoubledNameInvalid value, $Res Function(DoubledNameInvalid) then) =
      _$DoubledNameInvalidCopyWithImpl<$Res>;
}

class _$DoubledNameInvalidCopyWithImpl<$Res>
    extends _$BackendFailureCopyWithImpl<$Res>
    implements $DoubledNameInvalidCopyWith<$Res> {
  _$DoubledNameInvalidCopyWithImpl(
      DoubledNameInvalid _value, $Res Function(DoubledNameInvalid) _then)
      : super(_value, (v) => _then(v as DoubledNameInvalid));

  @override
  DoubledNameInvalid get _value => super._value as DoubledNameInvalid;
}

class _$DoubledNameInvalid implements DoubledNameInvalid {
  const _$DoubledNameInvalid();

  @override
  String toString() {
    return 'BackendFailure.doubledNameInvalid()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is DoubledNameInvalid);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result nameInvalid(),
    @required Result doubledNameInvalid(),
    @required Result serverError(),
  }) {
    assert(nameInvalid != null);
    assert(doubledNameInvalid != null);
    assert(serverError != null);
    return doubledNameInvalid();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result nameInvalid(),
    Result doubledNameInvalid(),
    Result serverError(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (doubledNameInvalid != null) {
      return doubledNameInvalid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result nameInvalid(NameInvalid value),
    @required Result doubledNameInvalid(DoubledNameInvalid value),
    @required Result serverError(ServerError value),
  }) {
    assert(nameInvalid != null);
    assert(doubledNameInvalid != null);
    assert(serverError != null);
    return doubledNameInvalid(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result nameInvalid(NameInvalid value),
    Result doubledNameInvalid(DoubledNameInvalid value),
    Result serverError(ServerError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (doubledNameInvalid != null) {
      return doubledNameInvalid(this);
    }
    return orElse();
  }
}

abstract class DoubledNameInvalid implements BackendFailure {
  const factory DoubledNameInvalid() = _$DoubledNameInvalid;
}

abstract class $ServerErrorCopyWith<$Res> {
  factory $ServerErrorCopyWith(
          ServerError value, $Res Function(ServerError) then) =
      _$ServerErrorCopyWithImpl<$Res>;
}

class _$ServerErrorCopyWithImpl<$Res> extends _$BackendFailureCopyWithImpl<$Res>
    implements $ServerErrorCopyWith<$Res> {
  _$ServerErrorCopyWithImpl(
      ServerError _value, $Res Function(ServerError) _then)
      : super(_value, (v) => _then(v as ServerError));

  @override
  ServerError get _value => super._value as ServerError;
}

class _$ServerError implements ServerError {
  const _$ServerError();

  @override
  String toString() {
    return 'BackendFailure.serverError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ServerError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result nameInvalid(),
    @required Result doubledNameInvalid(),
    @required Result serverError(),
  }) {
    assert(nameInvalid != null);
    assert(doubledNameInvalid != null);
    assert(serverError != null);
    return serverError();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result nameInvalid(),
    Result doubledNameInvalid(),
    Result serverError(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result nameInvalid(NameInvalid value),
    @required Result doubledNameInvalid(DoubledNameInvalid value),
    @required Result serverError(ServerError value),
  }) {
    assert(nameInvalid != null);
    assert(doubledNameInvalid != null);
    assert(serverError != null);
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result nameInvalid(NameInvalid value),
    Result doubledNameInvalid(DoubledNameInvalid value),
    Result serverError(ServerError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class ServerError implements BackendFailure {
  const factory ServerError() = _$ServerError;
}
